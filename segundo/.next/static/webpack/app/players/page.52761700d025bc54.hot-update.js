"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/players/page",{

/***/ "(app-pages-browser)/./src/services/firebase.ts":
/*!**********************************!*\
  !*** ./src/services/firebase.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   auth: () => (/* binding */ auth),\n/* harmony export */   createUserWithEmailVerification: () => (/* binding */ createUserWithEmailVerification),\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   deleteUserAccount: () => (/* binding */ deleteUserAccount),\n/* harmony export */   exploreFirebaseData: () => (/* binding */ exploreFirebaseData),\n/* harmony export */   getCurrentStreamingData: () => (/* binding */ getCurrentStreamingData),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   isEmailVerified: () => (/* binding */ isEmailVerified),\n/* harmony export */   isUserAuthenticated: () => (/* binding */ isUserAuthenticated),\n/* harmony export */   listenToStreamControl: () => (/* binding */ listenToStreamControl),\n/* harmony export */   listenToStreamingData: () => (/* binding */ listenToStreamingData),\n/* harmony export */   resendEmailVerification: () => (/* binding */ resendEmailVerification),\n/* harmony export */   sendPasswordReset: () => (/* binding */ sendPasswordReset),\n/* harmony export */   signInUser: () => (/* binding */ signInUser),\n/* harmony export */   signOutUser: () => (/* binding */ signOutUser),\n/* harmony export */   updateStreamControl: () => (/* binding */ updateStreamControl),\n/* harmony export */   updateUserPassword: () => (/* binding */ updateUserPassword)\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* harmony import */ var _config_firebase_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/firebase.config */ \"(app-pages-browser)/./src/config/firebase.config.ts\");\n\n\n\n\n// Validate Firebase configuration on startup\n(0,_config_firebase_config__WEBPACK_IMPORTED_MODULE_3__.validateFirebaseConfig)();\n// Initialize Firebase\nconst app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(_config_firebase_config__WEBPACK_IMPORTED_MODULE_3__.firebaseConfig);\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(app);\nconst auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.getAuth)(app);\n// Helper function to safely convert Firestore values to Date\nconst toSafeDate = (value)=>{\n    if (!value) return new Date(0);\n    if (value instanceof Date) return value;\n    if (typeof value === \"string\" || typeof value === \"number\") {\n        const d = new Date(value);\n        return isNaN(d.getTime()) ? new Date(0) : d;\n    }\n    if (typeof value === \"object\" && value !== null && \"toDate\" in value) {\n        return value.toDate();\n    }\n    const d = new Date(value);\n    return isNaN(d.getTime()) ? new Date(0) : d;\n};\n// Listen to streaming data in real-time\nconst listenToStreamingData = (callback)=>{\n    console.log(\"ðŸ” Segundo listening to: streaming/avryzcqeibphtefihmsrjfbugeq1\");\n    const streamingRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"streaming\", \"avryzcqeibphtefihmsrjfbugeq1\");\n    return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)(streamingRef, (doc)=>{\n        console.log(\"ðŸ” Firebase snapshot received:\", doc.exists() ? \"Document exists\" : \"Document does not exist\");\n        if (doc.exists()) {\n            const raw = doc.data();\n            // Handle mobile app's data structure\n            const overview = raw.overview || {};\n            const roundsData = raw.rounds || {};\n            // Debug: Log the raw data structure\n            console.log(\"ðŸ” Raw Firebase data:\", raw);\n            console.log(\"ðŸ” Overview data:\", overview);\n            console.log(\"ðŸ” Raw teams:\", raw.teams);\n            console.log(\"ðŸ” Overview teams:\", overview.teams);\n            console.log(\"ðŸ” Rounds data:\", roundsData);\n            console.log(\"ðŸ” Champion data:\", raw.champion);\n            // Check for other possible team data locations\n            console.log(\"ðŸ” All raw data keys:\", Object.keys(raw));\n            console.log(\"ðŸ” All overview keys:\", Object.keys(overview));\n            // Look for teams in other possible locations\n            if (raw.teamsData) console.log(\"ðŸ” teamsData:\", raw.teamsData);\n            if (raw.teamList) console.log(\"ðŸ” teamList:\", raw.teamList);\n            if (raw.participants) console.log(\"ðŸ” participants:\", raw.participants);\n            if (overview.teamsData) console.log(\"ðŸ” overview.teamsData:\", overview.teamsData);\n            if (overview.teamList) console.log(\"ðŸ” overview.teamList:\", overview.teamList);\n            if (overview.participants) console.log(\"ðŸ” overview.participants:\", overview.participants);\n            // Debug: Log detailed rounds structure\n            Object.entries(roundsData).forEach((param)=>{\n                let [roundKey, roundData] = param;\n                console.log(\"\\uD83D\\uDD0D Round \".concat(roundKey, \":\"), roundData);\n                if (roundData && typeof roundData === \"object\" && roundData !== null && \"matches\" in roundData && Array.isArray(roundData.matches)) {\n                    const round = roundData;\n                    round.matches.forEach((match, matchIndex)=>{\n                        console.log(\"\\uD83D\\uDD0D Match \".concat(matchIndex, \" in \").concat(roundKey, \":\"), match);\n                        if (match && typeof match === \"object\" && match !== null) {\n                            const matchObj = match;\n                            if (matchObj.team1) console.log(\"\\uD83D\\uDD0D Team1 details:\", matchObj.team1);\n                            if (matchObj.team2) console.log(\"\\uD83D\\uDD0D Team2 details:\", matchObj.team2);\n                        }\n                    });\n                }\n            });\n            // Extract teams from rounds data if teams array is empty\n            let teams = [];\n            console.log(\"ðŸ” Raw teams array:\", raw.teams);\n            console.log(\"ðŸ” Overview teams array:\", overview.teams);\n            if (Array.isArray(raw.teams) && raw.teams.length > 0) {\n                console.log(\"ðŸ” Using raw.teams:\", raw.teams.length, \"teams\");\n                teams = raw.teams;\n            } else if (Array.isArray(overview.teams) && overview.teams.length > 0) {\n                console.log(\"ðŸ” Using overview.teams:\", overview.teams.length, \"teams\");\n                teams = overview.teams;\n            } else {\n                console.log(\"ðŸ” Extracting teams from rounds data...\");\n                // Extract teams from rounds data\n                const teamMap = new Map();\n                Object.values(roundsData).forEach((round, roundIndex)=>{\n                    console.log(\"\\uD83D\\uDD0D Processing round \".concat(roundIndex, \":\"), round);\n                    if (round && round.matches && Array.isArray(round.matches)) {\n                        // Check for team1 and team2 in matches\n                        const roundData = round;\n                        if (roundData.matches && Array.isArray(roundData.matches)) {\n                            roundData.matches.forEach((match)=>{\n                                if (match && typeof match === \"object\" && match !== null && \"team1\" in match && \"team2\" in match) {\n                                    var _matchData_team1, _matchData_team2;\n                                    const matchData = match;\n                                    if (matchData.team1 && matchData.team1.id && ((_matchData_team1 = matchData.team1) === null || _matchData_team1 === void 0 ? void 0 : _matchData_team1.name) && matchData.team1.name !== \"Unknown Team\" && matchData.team1.name.trim().length > 0) {\n                                        var _matchData_team11;\n                                        console.log(\"\\uD83D\\uDD0D Found team1: \".concat(((_matchData_team11 = matchData.team1) === null || _matchData_team11 === void 0 ? void 0 : _matchData_team11.name) || \"Unknown\", \" (\").concat(matchData.team1.id, \")\"));\n                                        if (!teamMap.has(matchData.team1.id)) {\n                                            var _matchData_team12, _matchData_team13;\n                                            // Parse playerNames string into individual players\n                                            const players = [];\n                                            if (matchData.team1.playerNames && typeof matchData.team1.playerNames === \"string\") {\n                                                var _matchData_team14, _matchData_team15, _matchData_team16, _matchData_team17;\n                                                console.log(\"\\uD83D\\uDD0D Team1 \".concat(((_matchData_team14 = matchData.team1) === null || _matchData_team14 === void 0 ? void 0 : _matchData_team14.name) || \"Unknown\", \" playerNames string:\"), matchData.team1.playerNames);\n                                                const rawPlayerNames = matchData.team1.playerNames.split(\",\");\n                                                console.log(\"\\uD83D\\uDD0D Team1 \".concat(((_matchData_team15 = matchData.team1) === null || _matchData_team15 === void 0 ? void 0 : _matchData_team15.name) || \"Unknown\", \" raw split:\"), rawPlayerNames);\n                                                const trimmedPlayerNames = rawPlayerNames.map((name)=>name.trim());\n                                                console.log(\"\\uD83D\\uDD0D Team1 \".concat(((_matchData_team16 = matchData.team1) === null || _matchData_team16 === void 0 ? void 0 : _matchData_team16.name) || \"Unknown\", \" after trim:\"), trimmedPlayerNames);\n                                                const playerNames = trimmedPlayerNames.filter((name)=>{\n                                                    var _matchData_team1;\n                                                    const isValid = name && name.length > 0 && name !== \"Player\";\n                                                    console.log(\"\\uD83D\\uDD0D Team1 \".concat(((_matchData_team1 = matchData.team1) === null || _matchData_team1 === void 0 ? void 0 : _matchData_team1.name) || \"Unknown\", ' filtering \"').concat(name, '\": ').concat(isValid));\n                                                    return isValid;\n                                                });\n                                                console.log(\"\\uD83D\\uDD0D Team1 \".concat(((_matchData_team17 = matchData.team1) === null || _matchData_team17 === void 0 ? void 0 : _matchData_team17.name) || \"Unknown\", \" parsed player names:\"), playerNames);\n                                                playerNames.forEach((playerName, index)=>{\n                                                    players.push({\n                                                        id: \"\".concat(matchData.team1.id, \"_player_\").concat(index),\n                                                        name: playerName,\n                                                        captain: false\n                                                    });\n                                                });\n                                            }\n                                            console.log(\"\\uD83D\\uDD0D Creating team1: \".concat(((_matchData_team12 = matchData.team1) === null || _matchData_team12 === void 0 ? void 0 : _matchData_team12.name) || \"Unknown\", \" with \").concat(players.length, \" players\"));\n                                            teamMap.set(matchData.team1.id, {\n                                                id: matchData.team1.id,\n                                                name: ((_matchData_team13 = matchData.team1) === null || _matchData_team13 === void 0 ? void 0 : _matchData_team13.name) || \"Unknown\",\n                                                manager: \"\",\n                                                captain: \"\",\n                                                players: players,\n                                                color: \"\",\n                                                icon: \"\"\n                                            });\n                                        }\n                                    }\n                                    if (matchData.team2 && matchData.team2.id && ((_matchData_team2 = matchData.team2) === null || _matchData_team2 === void 0 ? void 0 : _matchData_team2.name) && matchData.team2.name !== \"Unknown Team\" && matchData.team2.name.trim().length > 0) {\n                                        var _matchData_team21;\n                                        console.log(\"\\uD83D\\uDD0D Found team2: \".concat(((_matchData_team21 = matchData.team2) === null || _matchData_team21 === void 0 ? void 0 : _matchData_team21.name) || \"Unknown\", \" (\").concat(matchData.team2.id, \")\"));\n                                        if (!teamMap.has(matchData.team2.id)) {\n                                            var _matchData_team22, _matchData_team23;\n                                            // Parse playerNames string into individual players\n                                            const players = [];\n                                            if (matchData.team2.playerNames && typeof matchData.team2.playerNames === \"string\") {\n                                                var _matchData_team24, _matchData_team25, _matchData_team26, _matchData_team27;\n                                                console.log(\"\\uD83D\\uDD0D Team2 \".concat(((_matchData_team24 = matchData.team2) === null || _matchData_team24 === void 0 ? void 0 : _matchData_team24.name) || \"Unknown\", \" playerNames string:\"), matchData.team2.playerNames);\n                                                const rawPlayerNames = matchData.team2.playerNames.split(\",\");\n                                                console.log(\"\\uD83D\\uDD0D Team2 \".concat(((_matchData_team25 = matchData.team2) === null || _matchData_team25 === void 0 ? void 0 : _matchData_team25.name) || \"Unknown\", \" raw split:\"), rawPlayerNames);\n                                                const trimmedPlayerNames = rawPlayerNames.map((name)=>name.trim());\n                                                console.log(\"\\uD83D\\uDD0D Team2 \".concat(((_matchData_team26 = matchData.team2) === null || _matchData_team26 === void 0 ? void 0 : _matchData_team26.name) || \"Unknown\", \" after trim:\"), trimmedPlayerNames);\n                                                const playerNames = trimmedPlayerNames.filter((name)=>{\n                                                    var _matchData_team2;\n                                                    const isValid = name && name.length > 0 && name !== \"Player\";\n                                                    console.log(\"\\uD83D\\uDD0D Team2 \".concat(((_matchData_team2 = matchData.team2) === null || _matchData_team2 === void 0 ? void 0 : _matchData_team2.name) || \"Unknown\", ' filtering \"').concat(name, '\": ').concat(isValid));\n                                                    return isValid;\n                                                });\n                                                console.log(\"\\uD83D\\uDD0D Team2 \".concat(((_matchData_team27 = matchData.team2) === null || _matchData_team27 === void 0 ? void 0 : _matchData_team27.name) || \"Unknown\", \" parsed player names:\"), playerNames);\n                                                playerNames.forEach((playerName, index)=>{\n                                                    players.push({\n                                                        id: \"\".concat(matchData.team2.id, \"_player_\").concat(index),\n                                                        name: playerName,\n                                                        captain: false\n                                                    });\n                                                });\n                                            }\n                                            console.log(\"\\uD83D\\uDD0D Creating team2: \".concat(((_matchData_team22 = matchData.team2) === null || _matchData_team22 === void 0 ? void 0 : _matchData_team22.name) || \"Unknown\", \" with \").concat(players.length, \" players\"));\n                                            teamMap.set(matchData.team2.id, {\n                                                id: matchData.team2.id,\n                                                name: ((_matchData_team23 = matchData.team2) === null || _matchData_team23 === void 0 ? void 0 : _matchData_team23.name) || \"Unknown\",\n                                                manager: \"\",\n                                                captain: \"\",\n                                                players: players,\n                                                color: \"\",\n                                                icon: \"\"\n                                            });\n                                        }\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                teams = Array.from(teamMap.values());\n            }\n            // Debug: Log team and player counts\n            console.log(\"ðŸ” Total teams extracted:\", teams.length);\n            teams.forEach((team, index)=>{\n                var _team_players;\n                console.log(\"\\uD83D\\uDD0D Team \".concat(index + 1, \" (\").concat(team.name, \"): \").concat(((_team_players = team.players) === null || _team_players === void 0 ? void 0 : _team_players.length) || 0, \" players\"));\n                if (team.players) {\n                    team.players.forEach((player, playerIndex)=>{\n                        console.log(\"  Player \".concat(playerIndex + 1, \": \").concat(player.name));\n                    });\n                }\n            });\n            const data = {\n                id: raw.id || overview.tournamentId || \"current\",\n                name: overview.tournamentName || raw.name || \"Tournament\",\n                status: overview.status || raw.status || \"setup\",\n                currentRound: overview.currentRound || raw.currentRound || \"\",\n                teams: teams,\n                rounds: (Array.isArray(roundsData) ? roundsData : Object.entries(roundsData).filter((param)=>{\n                    let [, round] = param;\n                    return round && typeof round === \"object\";\n                }).sort((param, param1)=>{\n                    let [keyA] = param, [keyB] = param1;\n                    // Sort rounds in a consistent order: semiFinal1, semiFinal2, final\n                    const order = {\n                        semiFinal1: 1,\n                        semiFinal2: 2,\n                        final: 3\n                    };\n                    return (order[keyA] || 999) - (order[keyB] || 999);\n                }).map((param)=>{\n                    let [, round] = param;\n                    return round;\n                })).map((round)=>({\n                        ...round,\n                        team1Wins: round.team1Wins || 0,\n                        team2Wins: round.team2Wins || 0,\n                        winsNeeded: round.winsNeeded || 5\n                    })),\n                streamingMode: raw.streamingMode || \"normal\",\n                lastWebUpdate: toSafeDate(raw.lastWebUpdate),\n                pushedAt: toSafeDate(raw.pushedAt),\n                pushedBy: raw.pushedBy || \"\"\n            };\n            callback(data);\n        } else {\n            callback(null);\n        }\n    }, (error)=>{\n        console.error(\"Error listening to streaming data:\", error);\n        callback(null);\n    });\n};\n// Get current streaming data (one-time read)\nconst getCurrentStreamingData = async ()=>{\n    try {\n        const streamingRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"streaming\", \"5xrp8r77dxgrwwpejua9fsnrrhm1\");\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(streamingRef);\n        if (docSnap.exists()) {\n            const raw = docSnap.data();\n            // Handle mobile app's data structure\n            const overview = raw.overview || {};\n            const roundsData = raw.rounds || {};\n            const data = {\n                id: raw.id || overview.tournamentId || \"current\",\n                name: overview.tournamentName || raw.name || \"Tournament\",\n                status: overview.status || raw.status || \"setup\",\n                currentRound: overview.currentRound || raw.currentRound || \"\",\n                teams: Array.isArray(raw.teams) ? raw.teams : [],\n                rounds: (Array.isArray(roundsData) ? roundsData : Object.entries(roundsData).filter((param)=>{\n                    let [, round] = param;\n                    return round && typeof round === \"object\";\n                }).sort((param, param1)=>{\n                    let [keyA] = param, [keyB] = param1;\n                    // Sort rounds in a consistent order: semiFinal1, semiFinal2, final\n                    const order = {\n                        semiFinal1: 1,\n                        semiFinal2: 2,\n                        final: 3\n                    };\n                    return (order[keyA] || 999) - (order[keyB] || 999);\n                }).map((param)=>{\n                    let [, round] = param;\n                    return round;\n                })).map((round)=>({\n                        ...round,\n                        team1Wins: round.team1Wins || 0,\n                        team2Wins: round.team2Wins || 0,\n                        winsNeeded: round.winsNeeded || 5\n                    })),\n                streamingMode: raw.streamingMode || \"normal\",\n                lastWebUpdate: toSafeDate(raw.lastWebUpdate),\n                pushedAt: toSafeDate(raw.pushedAt),\n                pushedBy: raw.pushedBy || \"\"\n            };\n            return data;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting current streaming data:\", error);\n        return null;\n    }\n};\n// Listen to the stream control document in real-time\nconst listenToStreamControl = (callback)=>{\n    const streamControlRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"streaming\", \"current_stream_control\");\n    console.log(\"FIREBASE: Listening to stream control document...\");\n    return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)(streamControlRef, (doc)=>{\n        if (doc.exists()) {\n            console.log(\"FIREBASE: Stream control data received:\", doc.data());\n            callback(doc.data());\n        } else {\n            console.log(\"FIREBASE: Stream control document does not exist, providing default.\");\n            // If the document doesn't exist, provide a default state\n            callback({\n                streamMatches: [],\n                hiddenSections: []\n            });\n        }\n    }, (error)=>{\n        console.error(\"FIREBASE: Error listening to stream control:\", error);\n        // Provide a default state on error as well\n        callback({\n            streamMatches: [],\n            hiddenSections: []\n        });\n    });\n};\n// Update the stream control document\nconst updateStreamControl = async (data)=>{\n    try {\n        const streamControlRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"streaming\", \"current_stream_control\");\n        console.log(\"FIREBASE: Updating stream control with data:\", data);\n        // Use setDoc with merge: true to create the doc if it doesn't exist or update it if it does\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(streamControlRef, data, {\n            merge: true\n        });\n        console.log(\"FIREBASE: Stream control update successful.\");\n    } catch (error) {\n        console.error(\"FIREBASE: Error updating stream control:\", error);\n    }\n};\n// Explore existing Firebase data\nconst exploreFirebaseData = async ()=>{\n    try {\n        console.log(\"ðŸ” Exploring Firebase data...\");\n        console.log(\"âš ï¸ Note: Some collections may require authentication\");\n        // Try to check streaming collection first (most likely to be accessible)\n        try {\n            const streamingRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"streaming\", \"5xrp8r77dxgrwwpejua9fsnrrhm1\");\n            const streamingDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(streamingRef);\n            if (streamingDoc.exists()) {\n                console.log(\"âœ… ðŸ“¡ Streaming data found:\", streamingDoc.data());\n            } else {\n                console.log(\"ðŸ“¡ No streaming data found (collection exists but empty)\");\n            }\n        } catch (error) {\n            const firebaseError = error;\n            if (firebaseError.code === \"permission-denied\") {\n                console.log(\"âŒ ðŸ“¡ Streaming collection: Permission denied (needs authentication)\");\n            } else {\n                console.log(\"âŒ ðŸ“¡ Streaming collection error:\", firebaseError.message);\n            }\n        }\n        // Try to check users collection\n        try {\n            const usersRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, \"users\");\n            const usersSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(usersRef);\n            console.log(\"âœ… ðŸ‘¥ Users found:\", usersSnapshot.docs.length);\n            usersSnapshot.docs.forEach((doc)=>{\n                console.log(\"  - User \".concat(doc.id, \":\"), doc.data());\n            });\n        } catch (error) {\n            const firebaseError = error;\n            if (firebaseError.code === \"permission-denied\") {\n                console.log(\"âŒ ðŸ‘¥ Users collection: Permission denied (needs authentication)\");\n            } else {\n                console.log(\"âŒ ðŸ‘¥ Users collection error:\", firebaseError.message);\n            }\n        }\n        // Try to check for any other common collections\n        const commonCollections = [\n            \"tournaments\",\n            \"matches\",\n            \"teams\",\n            \"players\"\n        ];\n        for (const collectionName of commonCollections){\n            try {\n                const collectionRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(db, collectionName);\n                const snapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(collectionRef);\n                console.log(\"âœ… \\uD83D\\uDCC1 \".concat(collectionName, \" collection: \").concat(snapshot.docs.length, \" documents\"));\n                if (snapshot.docs.length > 0) {\n                    snapshot.docs.slice(0, 2).forEach((doc)=>{\n                        console.log(\"  - \".concat(collectionName, \" \").concat(doc.id, \":\"), doc.data());\n                    });\n                }\n            } catch (error) {\n                const firebaseError = error;\n                if (firebaseError.code === \"permission-denied\") {\n                    console.log(\"âŒ \\uD83D\\uDCC1 \".concat(collectionName, \" collection: Permission denied\"));\n                } else {\n                    console.log(\"âŒ \\uD83D\\uDCC1 \".concat(collectionName, \" collection error:\"), firebaseError.message);\n                }\n            }\n        }\n        console.log(\"ðŸ” Exploration complete!\");\n        return true;\n    } catch (error) {\n        console.error(\"âŒ Error exploring Firebase:\", error);\n        return false;\n    }\n};\n// ===== AUTHENTICATION FUNCTIONS =====\n// Email validation helper\nconst validateEmail = (email)=>{\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n};\n// Password validation helper\nconst validatePassword = (password)=>{\n    // Strong password: min 8 chars, uppercase, lowercase, number, special char\n    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/;\n    return passwordRegex.test(password);\n};\n// Create user with email verification\nconst createUserWithEmailVerification = async (email, password, displayName)=>{\n    try {\n        // Validate inputs\n        if (!validateEmail(email)) {\n            throw new Error(\"Invalid email format\");\n        }\n        if (!validatePassword(password)) {\n            throw new Error(\"Password must be at least 8 characters with uppercase, lowercase, number, and special character\");\n        }\n        if (!displayName || displayName.trim().length < 2) {\n            throw new Error(\"Name must be at least 2 characters\");\n        }\n        // Create user account\n        const userCredential = await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.createUserWithEmailAndPassword)(auth, email, password);\n        // Send email verification\n        await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.sendEmailVerification)(userCredential.user);\n        // Create user profile in Firestore\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"users\", userCredential.user.uid), {\n            displayName: displayName.trim(),\n            email,\n            emailVerified: false,\n            createdAt: new Date(),\n            isAdmin: false\n        });\n        return {\n            user: userCredential.user,\n            needsVerification: true,\n            message: \"Account created! Please check your email to verify your account.\"\n        };\n    } catch (error) {\n        const message = error instanceof Error ? error.message : \"Failed to create account\";\n        throw new Error(message);\n    }\n};\n// Sign in user\nconst signInUser = async (email, password)=>{\n    try {\n        const userCredential = await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.signInWithEmailAndPassword)(auth, email, password);\n        // Check if email is verified\n        if (!userCredential.user.emailVerified) {\n            await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.signOut)(auth);\n            throw new Error(\"Please verify your email before signing in. Check your inbox for the verification link.\");\n        }\n        return userCredential.user;\n    } catch (error) {\n        const message = error instanceof Error ? error.message : \"Failed to sign in\";\n        throw new Error(message);\n    }\n};\n// Sign out user\nconst signOutUser = async ()=>{\n    try {\n        await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.signOut)(auth);\n    } catch (error) {\n        const message = error instanceof Error ? error.message : \"Failed to sign out\";\n        throw new Error(message);\n    }\n};\n// Resend email verification\nconst resendEmailVerification = async ()=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new Error(\"No user logged in\");\n        }\n        await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.sendEmailVerification)(user);\n        return \"Verification email sent! Please check your inbox.\";\n    } catch (error) {\n        const message = error instanceof Error ? error.message : \"Failed to send verification email\";\n        throw new Error(message);\n    }\n};\n// Delete user account\nconst deleteUserAccount = async (password)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user || !user.email) {\n            throw new Error(\"No user logged in\");\n        }\n        // Re-authenticate user before deletion\n        const credential = firebase_auth__WEBPACK_IMPORTED_MODULE_2__.EmailAuthProvider.credential(user.email, password);\n        await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.reauthenticateWithCredential)(user, credential);\n        // Delete user data from Firestore\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(db, \"users\", user.uid));\n        // Delete user account\n        await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.deleteUser)(user);\n        return \"Account deleted successfully\";\n    } catch (error) {\n        const firebaseError = error;\n        const message = firebaseError.message || \"Failed to delete account\";\n        throw new Error(message);\n    }\n};\n// Get current user\nconst getCurrentUser = ()=>{\n    return auth.currentUser;\n};\n// Check if user is authenticated\nconst isUserAuthenticated = ()=>{\n    return !!auth.currentUser;\n};\n// Check if user email is verified\nconst isEmailVerified = ()=>{\n    var _auth_currentUser;\n    return ((_auth_currentUser = auth.currentUser) === null || _auth_currentUser === void 0 ? void 0 : _auth_currentUser.emailVerified) || false;\n};\n// Send password reset email\nconst sendPasswordReset = async (email)=>{\n    try {\n        // Validate email format\n        if (!validateEmail(email)) {\n            throw new Error(\"Invalid email format\");\n        }\n        await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.sendPasswordResetEmail)(auth, email);\n        return \"Password reset email sent! Please check your inbox and follow the instructions.\";\n    } catch (error) {\n        const firebaseError = error;\n        // Handle specific Firebase errors\n        if (firebaseError.code === \"auth/user-not-found\") {\n            throw new Error(\"No account found with this email address\");\n        } else if (firebaseError.code === \"auth/invalid-email\") {\n            throw new Error(\"Invalid email address\");\n        } else if (firebaseError.code === \"auth/too-many-requests\") {\n            throw new Error(\"Too many password reset attempts. Please try again later.\");\n        }\n        throw new Error(firebaseError.message || \"Failed to send password reset email\");\n    }\n};\n// Update password (for logged-in users)\nconst updateUserPassword = async (currentPassword, newPassword)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user || !user.email) {\n            throw new Error(\"No user logged in\");\n        }\n        // Validate new password\n        if (!validatePassword(newPassword)) {\n            throw new Error(\"New password must be at least 8 characters with uppercase, lowercase, number, and special character\");\n        }\n        // Re-authenticate user\n        const credential = firebase_auth__WEBPACK_IMPORTED_MODULE_2__.EmailAuthProvider.credential(user.email, currentPassword);\n        await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.reauthenticateWithCredential)(user, credential);\n        // Update password\n        await (0,firebase_auth__WEBPACK_IMPORTED_MODULE_2__.updatePassword)(user, newPassword);\n        return \"Password updated successfully\";\n    } catch (error) {\n        const firebaseError = error;\n        if (firebaseError.code === \"auth/wrong-password\") {\n            throw new Error(\"Current password is incorrect\");\n        } else if (firebaseError.code === \"auth/weak-password\") {\n            throw new Error(\"New password is too weak\");\n        }\n        throw new Error(firebaseError.message || \"Failed to update password\");\n    }\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9maXJlYmFzZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFXakI7QUFZTDtBQUlZO0FBT25DLDZDQUE2QztBQUM3Q29CLCtFQUFzQkE7QUFFdEIsc0JBQXNCO0FBQ3RCLE1BQU1DLE1BQU1yQiwyREFBYUEsQ0FBQ21CLG1FQUFjQTtBQUN4QyxNQUFNRyxLQUFLckIsZ0VBQVlBLENBQUNvQjtBQUN4QixNQUFNRSxPQUFPZCxzREFBT0EsQ0FBQ1k7QUEyRnJCLDZEQUE2RDtBQUM3RCxNQUFNRyxhQUFhLENBQUNDO0lBQ2xCLElBQUksQ0FBQ0EsT0FBTyxPQUFPLElBQUlDLEtBQUs7SUFDNUIsSUFBSUQsaUJBQWlCQyxNQUFNLE9BQU9EO0lBQ2xDLElBQUksT0FBT0EsVUFBVSxZQUFZLE9BQU9BLFVBQVUsVUFBVTtRQUMxRCxNQUFNRSxJQUFJLElBQUlELEtBQUtEO1FBQ25CLE9BQU9HLE1BQU1ELEVBQUVFLE9BQU8sTUFBTSxJQUFJSCxLQUFLLEtBQUtDO0lBQzVDO0lBQ0EsSUFBSSxPQUFPRixVQUFVLFlBQVlBLFVBQVUsUUFBUSxZQUFZQSxPQUFPO1FBQ3BFLE9BQU8sTUFBOEJLLE1BQU07SUFDN0M7SUFDQSxNQUFNSCxJQUFJLElBQUlELEtBQUtEO0lBQ25CLE9BQU9HLE1BQU1ELEVBQUVFLE9BQU8sTUFBTSxJQUFJSCxLQUFLLEtBQUtDO0FBQzVDO0FBU0Esd0NBQXdDO0FBQ2pDLE1BQU1JLHdCQUF3QixDQUNuQ0M7SUFFQUMsUUFBUUMsR0FBRyxDQUFDO0lBQ1osTUFBTUMsZUFBZWpDLHVEQUFHQSxDQUFDb0IsSUFBSSxhQUFhO0lBRTFDLE9BQU9uQiw4REFBVUEsQ0FDZmdDLGNBQ0EsQ0FBQ2pDO1FBQ0MrQixRQUFRQyxHQUFHLENBQ1Qsa0NBQ0FoQyxJQUFJa0MsTUFBTSxLQUFLLG9CQUFvQjtRQUVyQyxJQUFJbEMsSUFBSWtDLE1BQU0sSUFBSTtZQUNo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Y0MsSUFBSSxLQUFLLHNCQUFzQjtZQUN0RCxNQUFNLElBQUltQixNQUFNO1FBQ2xCLE9BQU8sSUFBSXBCLGNBQWNDLElBQUksS0FBSywwQkFBMEI7WUFDMUQsTUFBTSxJQUFJbUIsTUFDUjtRQUVKO1FBQ0EsTUFBTSxJQUFJQSxNQUNScEIsY0FBY0UsT0FBTyxJQUFJO0lBRTdCO0FBQ0YsRUFBRTtBQUVGLHdDQUF3QztBQUNqQyxNQUFNb0MscUJBQXFCLE9BQ2hDQyxpQkFDQUM7SUFFQSxJQUFJO1FBQ0YsTUFBTWxCLE9BQU94SCxLQUFLaUksV0FBVztRQUM3QixJQUFJLENBQUNULFFBQVEsQ0FBQ0EsS0FBS1YsS0FBSyxFQUFFO1lBQ3hCLE1BQU0sSUFBSVEsTUFBTTtRQUNsQjtRQUVBLHdCQUF3QjtRQUN4QixJQUFJLENBQUNMLGlCQUFpQnlCLGNBQWM7WUFDbEMsTUFBTSxJQUFJcEIsTUFDUjtRQUVKO1FBRUEsdUJBQXVCO1FBQ3ZCLE1BQU1hLGFBQWF4SSw0REFBaUJBLENBQUN3SSxVQUFVLENBQzdDWCxLQUFLVixLQUFLLEVBQ1YyQjtRQUVGLE1BQU0vSSwyRUFBNEJBLENBQUM4SCxNQUFNVztRQUV6QyxrQkFBa0I7UUFDbEIsTUFBTTFJLDZEQUFjQSxDQUFDK0gsTUFBTWtCO1FBRTNCLE9BQU87SUFDVCxFQUFFLE9BQU9uRCxPQUFPO1FBQ2QsTUFBTVcsZ0JBQWdCWDtRQUN0QixJQUFJVyxjQUFjQyxJQUFJLEtBQUssdUJBQXVCO1lBQ2hELE1BQU0sSUFBSW1CLE1BQU07UUFDbEIsT0FBTyxJQUFJcEIsY0FBY0MsSUFBSSxLQUFLLHNCQUFzQjtZQUN0RCxNQUFNLElBQUltQixNQUFNO1FBQ2xCO1FBQ0EsTUFBTSxJQUFJQSxNQUFNcEIsY0FBY0UsT0FBTyxJQUFJO0lBQzNDO0FBQ0YsRUFBRTtBQUVrQiIsInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkb25xdWl0L0xvY2FsRGV2L093ZW5zQ3VwL3NlZ3VuZG8vc3JjL3NlcnZpY2VzL2ZpcmViYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluaXRpYWxpemVBcHAgfSBmcm9tIFwiZmlyZWJhc2UvYXBwXCI7XG5pbXBvcnQge1xuICBnZXRGaXJlc3RvcmUsXG4gIGRvYyxcbiAgb25TbmFwc2hvdCxcbiAgZ2V0RG9jLFxuICBjb2xsZWN0aW9uLFxuICBnZXREb2NzLFxuICBEb2N1bWVudERhdGEsXG4gIHNldERvYyxcbiAgZGVsZXRlRG9jLFxufSBmcm9tIFwiZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5pbXBvcnQge1xuICBnZXRBdXRoLFxuICBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQsXG4gIHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkLFxuICBzaWduT3V0LFxuICBzZW5kRW1haWxWZXJpZmljYXRpb24sXG4gIHNlbmRQYXNzd29yZFJlc2V0RW1haWwsXG4gIGRlbGV0ZVVzZXIsXG4gIHVwZGF0ZVBhc3N3b3JkLFxuICByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsLFxuICBFbWFpbEF1dGhQcm92aWRlcixcbn0gZnJvbSBcImZpcmViYXNlL2F1dGhcIjtcbmltcG9ydCB7XG4gIGZpcmViYXNlQ29uZmlnLFxuICB2YWxpZGF0ZUZpcmViYXNlQ29uZmlnLFxufSBmcm9tIFwiLi4vY29uZmlnL2ZpcmViYXNlLmNvbmZpZ1wiO1xuXG4vLyBUeXBlIGZvciBGaXJlYmFzZSBlcnJvcnNcbmludGVyZmFjZSBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlPzogc3RyaW5nO1xufVxuXG4vLyBWYWxpZGF0ZSBGaXJlYmFzZSBjb25maWd1cmF0aW9uIG9uIHN0YXJ0dXBcbnZhbGlkYXRlRmlyZWJhc2VDb25maWcoKTtcblxuLy8gSW5pdGlhbGl6ZSBGaXJlYmFzZVxuY29uc3QgYXBwID0gaW5pdGlhbGl6ZUFwcChmaXJlYmFzZUNvbmZpZyk7XG5jb25zdCBkYiA9IGdldEZpcmVzdG9yZShhcHApO1xuY29uc3QgYXV0aCA9IGdldEF1dGgoYXBwKTtcblxuLy8gRmlyZXN0b3JlIGRvY3VtZW50IGRhdGEgaW50ZXJmYWNlXG5pbnRlcmZhY2UgRmlyZXN0b3JlRG9jdW1lbnREYXRhIGV4dGVuZHMgRG9jdW1lbnREYXRhIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIHN0YXR1cz86IHN0cmluZztcbiAgY3VycmVudFJvdW5kPzogc3RyaW5nO1xuICB0ZWFtcz86IFdlYlRlYW1bXTtcbiAgcm91bmRzPzogV2ViUm91bmRbXTtcbiAgc3RyZWFtaW5nTW9kZT86IHN0cmluZztcbiAgbGFzdFdlYlVwZGF0ZT86IEZpcmVzdG9yZVRpbWVzdGFtcDtcbiAgcHVzaGVkQXQ/OiBGaXJlc3RvcmVUaW1lc3RhbXA7XG4gIHB1c2hlZEJ5Pzogc3RyaW5nO1xufVxuXG4vLyBGaXJlc3RvcmUgVGltZXN0YW1wIGludGVyZmFjZVxuaW50ZXJmYWNlIEZpcmVzdG9yZVRpbWVzdGFtcCB7XG4gIHRvRGF0ZSgpOiBEYXRlO1xufVxuXG4vLyBUeXBlcyBmb3Igc3RyZWFtaW5nIGRhdGEgKG1hdGNoaW5nIG1vYmlsZSBhcHApXG5leHBvcnQgaW50ZXJmYWNlIFdlYlBsYXllciB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgY2FwdGFpbjogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWJUZWFtIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBtYW5hZ2VyOiBzdHJpbmc7XG4gIGNhcHRhaW46IHN0cmluZztcbiAgcGxheWVyczogV2ViUGxheWVyW107XG4gIGNvbG9yOiBzdHJpbmc7XG4gIGljb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWJNYXRjaCB7XG4gIG1hdGNoSWQ6IHN0cmluZztcbiAgcm91bmROYW1lOiBzdHJpbmc7XG4gIG1hdGNoTnVtYmVyOiBudW1iZXI7XG4gIHRlYW0xOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc2NvcmU6IG51bWJlcjtcbiAgICBjb2xvcjogc3RyaW5nO1xuICAgIGljb246IHN0cmluZztcbiAgfTtcbiAgdGVhbTI6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzY29yZTogbnVtYmVyO1xuICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgaWNvbjogc3RyaW5nO1xuICB9O1xuICBpc0NvbXBsZXRlZDogYm9vbGVhbjtcbiAgd2lubmVySWQ6IHN0cmluZyB8IG51bGw7XG4gIHJhY2VUb1Njb3JlOiBudW1iZXI7XG4gIGxhc3RVcGRhdGVkOiBEYXRlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlJvdW5kIHtcbiAgcm91bmROYW1lOiBzdHJpbmc7XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICB3aW5uZXJUZWFtSWQ6IHN0cmluZyB8IG51bGw7XG4gIG1hdGNoZXM6IFdlYk1hdGNoW107XG4gIHRlYW0xV2luczogbnVtYmVyO1xuICB0ZWFtMldpbnM6IG51bWJlcjtcbiAgd2luc05lZWRlZDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlRvdXJuYW1lbnREYXRhIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBzdGF0dXM6IFwic2V0dXBcIiB8IFwibGl2ZVwiIHwgXCJjb21wbGV0ZWRcIjtcbiAgY3VycmVudFJvdW5kOiBzdHJpbmc7XG4gIHRlYW1zOiBXZWJUZWFtW107XG4gIHJvdW5kczogV2ViUm91bmRbXTtcbiAgc3RyZWFtaW5nTW9kZTogXCJub3JtYWxcIiB8IFwic3RyZWFtaW5nXCIgfCBcIm1hbnVhbFwiO1xuICBsYXN0V2ViVXBkYXRlOiBEYXRlIHwgbnVsbDtcbiAgcHVzaGVkQXQ6IERhdGUgfCBudWxsO1xuICBwdXNoZWRCeTogc3RyaW5nO1xufVxuXG4vLyBUeXBlcyBmb3IgdGhlIG5ldyBTdHJlYW0gQ29udHJvbCBkb2N1bWVudFxuZXhwb3J0IGludGVyZmFjZSBTdHJlYW1Db250cm9sRGF0YSB7XG4gIHN0cmVhbU1hdGNoZXM6IHN0cmluZ1tdO1xuICBoaWRkZW5TZWN0aW9uczogc3RyaW5nW107XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBzYWZlbHkgY29udmVydCBGaXJlc3RvcmUgdmFsdWVzIHRvIERhdGVcbmNvbnN0IHRvU2FmZURhdGUgPSAodmFsdWU6IHVua25vd24pOiBEYXRlID0+IHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIG5ldyBEYXRlKDApO1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdmFsdWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICByZXR1cm4gaXNOYU4oZC5nZXRUaW1lKCkpID8gbmV3IERhdGUoMCkgOiBkO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgXCJ0b0RhdGVcIiBpbiB2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgYXMgRmlyZXN0b3JlVGltZXN0YW1wKS50b0RhdGUoKTtcbiAgfVxuICBjb25zdCBkID0gbmV3IERhdGUodmFsdWUgYXMgc3RyaW5nIHwgbnVtYmVyIHwgRGF0ZSk7XG4gIHJldHVybiBpc05hTihkLmdldFRpbWUoKSkgPyBuZXcgRGF0ZSgwKSA6IGQ7XG59O1xuXG4vLyBUeXBlIGZvciB0aGUgbmVzdGVkIHJvdW5kcyBvYmplY3RcbnR5cGUgUm91bmRzRGF0YSA9XG4gIHwge1xuICAgICAgW2tleTogc3RyaW5nXTogUGFydGlhbDxXZWJSb3VuZD47XG4gICAgfVxuICB8IFdlYlJvdW5kW107XG5cbi8vIExpc3RlbiB0byBzdHJlYW1pbmcgZGF0YSBpbiByZWFsLXRpbWVcbmV4cG9ydCBjb25zdCBsaXN0ZW5Ub1N0cmVhbWluZ0RhdGEgPSAoXG4gIGNhbGxiYWNrOiAoZGF0YTogV2ViVG91cm5hbWVudERhdGEgfCBudWxsKSA9PiB2b2lkXG4pID0+IHtcbiAgY29uc29sZS5sb2coXCLwn5SNIFNlZ3VuZG8gbGlzdGVuaW5nIHRvOiBzdHJlYW1pbmcvYXZyeXpjcWVpYnBodGVmaWhtc3JqZmJ1Z2VxMVwiKTtcbiAgY29uc3Qgc3RyZWFtaW5nUmVmID0gZG9jKGRiLCBcInN0cmVhbWluZ1wiLCBcImF2cnl6Y3FlaWJwaHRlZmlobXNyamZidWdlcTFcIik7XG5cbiAgcmV0dXJuIG9uU25hcHNob3QoXG4gICAgc3RyZWFtaW5nUmVmLFxuICAgIChkb2MpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIvCflI0gRmlyZWJhc2Ugc25hcHNob3QgcmVjZWl2ZWQ6XCIsXG4gICAgICAgIGRvYy5leGlzdHMoKSA/IFwiRG9jdW1lbnQgZXhpc3RzXCIgOiBcIkRvY3VtZW50IGRvZXMgbm90IGV4aXN0XCJcbiAgICAgICk7XG4gICAgICBpZiAoZG9jLmV4aXN0cygpKSB7XG4gICAgICAgIGNvbnN0IHJhdyA9IGRvYy5kYXRhKCkgYXMgRmlyZXN0b3JlRG9jdW1lbnREYXRhO1xuXG4gICAgICAgIC8vIEhhbmRsZSBtb2JpbGUgYXBwJ3MgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgY29uc3Qgb3ZlcnZpZXcgPSAocmF3Lm92ZXJ2aWV3IHx8IHt9KSBhcyBEb2N1bWVudERhdGE7XG4gICAgICAgIGNvbnN0IHJvdW5kc0RhdGE6IFJvdW5kc0RhdGEgPSAocmF3LnJvdW5kcyB8fCB7fSkgYXMgUm91bmRzRGF0YTtcblxuICAgICAgICAvLyBEZWJ1ZzogTG9nIHRoZSByYXcgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIFJhdyBGaXJlYmFzZSBkYXRhOlwiLCByYXcpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gT3ZlcnZpZXcgZGF0YTpcIiwgb3ZlcnZpZXcpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gUmF3IHRlYW1zOlwiLCByYXcudGVhbXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gT3ZlcnZpZXcgdGVhbXM6XCIsIG92ZXJ2aWV3LnRlYW1zKTtcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIFJvdW5kcyBkYXRhOlwiLCByb3VuZHNEYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIENoYW1waW9uIGRhdGE6XCIsIHJhdy5jaGFtcGlvbik7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG90aGVyIHBvc3NpYmxlIHRlYW0gZGF0YSBsb2NhdGlvbnNcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIEFsbCByYXcgZGF0YSBrZXlzOlwiLCBPYmplY3Qua2V5cyhyYXcpKTtcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIEFsbCBvdmVydmlldyBrZXlzOlwiLCBPYmplY3Qua2V5cyhvdmVydmlldykpO1xuXG4gICAgICAgIC8vIExvb2sgZm9yIHRlYW1zIGluIG90aGVyIHBvc3NpYmxlIGxvY2F0aW9uc1xuICAgICAgICBpZiAocmF3LnRlYW1zRGF0YSkgY29uc29sZS5sb2coXCLwn5SNIHRlYW1zRGF0YTpcIiwgcmF3LnRlYW1zRGF0YSk7XG4gICAgICAgIGlmIChyYXcudGVhbUxpc3QpIGNvbnNvbGUubG9nKFwi8J+UjSB0ZWFtTGlzdDpcIiwgcmF3LnRlYW1MaXN0KTtcbiAgICAgICAgaWYgKHJhdy5wYXJ0aWNpcGFudHMpIGNvbnNvbGUubG9nKFwi8J+UjSBwYXJ0aWNpcGFudHM6XCIsIHJhdy5wYXJ0aWNpcGFudHMpO1xuICAgICAgICBpZiAob3ZlcnZpZXcudGVhbXNEYXRhKVxuICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBvdmVydmlldy50ZWFtc0RhdGE6XCIsIG92ZXJ2aWV3LnRlYW1zRGF0YSk7XG4gICAgICAgIGlmIChvdmVydmlldy50ZWFtTGlzdClcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gb3ZlcnZpZXcudGVhbUxpc3Q6XCIsIG92ZXJ2aWV3LnRlYW1MaXN0KTtcbiAgICAgICAgaWYgKG92ZXJ2aWV3LnBhcnRpY2lwYW50cylcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gb3ZlcnZpZXcucGFydGljaXBhbnRzOlwiLCBvdmVydmlldy5wYXJ0aWNpcGFudHMpO1xuXG4gICAgICAgIC8vIERlYnVnOiBMb2cgZGV0YWlsZWQgcm91bmRzIHN0cnVjdHVyZVxuICAgICAgICBPYmplY3QuZW50cmllcyhyb3VuZHNEYXRhKS5mb3JFYWNoKChbcm91bmRLZXksIHJvdW5kRGF0YV0pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBSb3VuZCAke3JvdW5kS2V5fTpgLCByb3VuZERhdGEpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHJvdW5kRGF0YSAmJlxuICAgICAgICAgICAgdHlwZW9mIHJvdW5kRGF0YSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgcm91bmREYXRhICE9PSBudWxsICYmXG4gICAgICAgICAgICBcIm1hdGNoZXNcIiBpbiByb3VuZERhdGEgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocm91bmREYXRhLm1hdGNoZXMpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCByb3VuZCA9IHJvdW5kRGF0YSBhcyB7IG1hdGNoZXM6IFdlYk1hdGNoW10gfTtcbiAgICAgICAgICAgIHJvdW5kLm1hdGNoZXMuZm9yRWFjaCgobWF0Y2g6IFdlYk1hdGNoLCBtYXRjaEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gTWF0Y2ggJHttYXRjaEluZGV4fSBpbiAke3JvdW5kS2V5fTpgLCBtYXRjaCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCAmJiB0eXBlb2YgbWF0Y2ggPT09IFwib2JqZWN0XCIgJiYgbWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaE9iaiA9IG1hdGNoIGFzIHtcbiAgICAgICAgICAgICAgICAgIHRlYW0xPzogdW5rbm93bjtcbiAgICAgICAgICAgICAgICAgIHRlYW0yPzogdW5rbm93bjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaE9iai50ZWFtMSlcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFRlYW0xIGRldGFpbHM6YCwgbWF0Y2hPYmoudGVhbTEpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaE9iai50ZWFtMilcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFRlYW0yIGRldGFpbHM6YCwgbWF0Y2hPYmoudGVhbTIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgdGVhbXMgZnJvbSByb3VuZHMgZGF0YSBpZiB0ZWFtcyBhcnJheSBpcyBlbXB0eVxuICAgICAgICBsZXQgdGVhbXM6IFdlYlRlYW1bXSA9IFtdO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBSYXcgdGVhbXMgYXJyYXk6XCIsIHJhdy50ZWFtcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBPdmVydmlldyB0ZWFtcyBhcnJheTpcIiwgb3ZlcnZpZXcudGVhbXMpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhdy50ZWFtcykgJiYgcmF3LnRlYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gVXNpbmcgcmF3LnRlYW1zOlwiLCByYXcudGVhbXMubGVuZ3RoLCBcInRlYW1zXCIpO1xuICAgICAgICAgIHRlYW1zID0gcmF3LnRlYW1zO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3ZlcnZpZXcudGVhbXMpICYmIG92ZXJ2aWV3LnRlYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwi8J+UjSBVc2luZyBvdmVydmlldy50ZWFtczpcIixcbiAgICAgICAgICAgIG92ZXJ2aWV3LnRlYW1zLmxlbmd0aCxcbiAgICAgICAgICAgIFwidGVhbXNcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdGVhbXMgPSBvdmVydmlldy50ZWFtcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gRXh0cmFjdGluZyB0ZWFtcyBmcm9tIHJvdW5kcyBkYXRhLi4uXCIpO1xuICAgICAgICAgIC8vIEV4dHJhY3QgdGVhbXMgZnJvbSByb3VuZHMgZGF0YVxuICAgICAgICAgIGNvbnN0IHRlYW1NYXAgPSBuZXcgTWFwPHN0cmluZywgV2ViVGVhbT4oKTtcblxuICAgICAgICAgIE9iamVjdC52YWx1ZXMocm91bmRzRGF0YSkuZm9yRWFjaChcbiAgICAgICAgICAgIChyb3VuZDogUGFydGlhbDxXZWJSb3VuZD4sIHJvdW5kSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBQcm9jZXNzaW5nIHJvdW5kICR7cm91bmRJbmRleH06YCwgcm91bmQpO1xuICAgICAgICAgICAgICBpZiAocm91bmQgJiYgcm91bmQubWF0Y2hlcyAmJiBBcnJheS5pc0FycmF5KHJvdW5kLm1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRlYW0xIGFuZCB0ZWFtMiBpbiBtYXRjaGVzXG4gICAgICAgICAgICAgICAgY29uc3Qgcm91bmREYXRhID0gcm91bmQgYXMgeyBtYXRjaGVzOiBXZWJNYXRjaFtdIH07XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kRGF0YS5tYXRjaGVzICYmIEFycmF5LmlzQXJyYXkocm91bmREYXRhLm1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgICByb3VuZERhdGEubWF0Y2hlcy5mb3JFYWNoKChtYXRjaDogV2ViTWF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG1hdGNoID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICBcInRlYW0xXCIgaW4gbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgICBcInRlYW0yXCIgaW4gbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hEYXRhID0gbWF0Y2ggYXMge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVhbTE/OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkPzogc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPzogc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJOYW1lcz86IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFtMj86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ/OiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllck5hbWVzPzogc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hEYXRhLnRlYW0xLmlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTE/Lm5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMS5uYW1lICE9PSBcIlVua25vd24gVGVhbVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTEubmFtZS50cmltKCkubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGDwn5SNIEZvdW5kIHRlYW0xOiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMT8ubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9ICgke21hdGNoRGF0YS50ZWFtMS5pZH0pYFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVhbU1hcC5oYXMobWF0Y2hEYXRhLnRlYW0xLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBwbGF5ZXJOYW1lcyBzdHJpbmcgaW50byBpbmRpdmlkdWFsIHBsYXllcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxheWVyczogV2ViUGxheWVyW10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMS5wbGF5ZXJOYW1lcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBtYXRjaERhdGEudGVhbTEucGxheWVyTmFtZXMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBg8J+UjSBUZWFtMSAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTE/Lm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gcGxheWVyTmFtZXMgc3RyaW5nOmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTEucGxheWVyTmFtZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd1BsYXllck5hbWVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMS5wbGF5ZXJOYW1lcy5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBg8J+UjSBUZWFtMSAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTE/Lm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gcmF3IHNwbGl0OmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdQbGF5ZXJOYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFBsYXllck5hbWVzID0gcmF3UGxheWVyTmFtZXMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWU6IHN0cmluZykgPT4gbmFtZS50cmltKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYPCflI0gVGVhbTEgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hEYXRhLnRlYW0xPy5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFmdGVyIHRyaW06YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW1tZWRQbGF5ZXJOYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxheWVyTmFtZXMgPSB0cmltbWVkUGxheWVyTmFtZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICYmIG5hbWUubGVuZ3RoID4gMCAmJiBuYW1lICE9PSBcIlBsYXllclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBg8J+UjSBUZWFtMSAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hEYXRhLnRlYW0xPy5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaWx0ZXJpbmcgXCIke25hbWV9XCI6ICR7aXNWYWxpZH1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBg8J+UjSBUZWFtMSAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTE/Lm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gcGFyc2VkIHBsYXllciBuYW1lczpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyTmFtZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllck5hbWVzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGxheWVyTmFtZTogc3RyaW5nLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGAke21hdGNoRGF0YS50ZWFtMSEuaWR9X3BsYXllcl8ke2luZGV4fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGxheWVyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0YWluOiBmYWxzZSwgLy8gQWxsIHBsYXllcnMgYXJlIHJlZ3VsYXIgcGxheWVycyBmb3IgcmFua2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYPCflI0gQ3JlYXRpbmcgdGVhbTE6ICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTE/Lm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdpdGggJHtwbGF5ZXJzLmxlbmd0aH0gcGxheWVyc2BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGVhbU1hcC5zZXQobWF0Y2hEYXRhLnRlYW0xLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1hdGNoRGF0YS50ZWFtMS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRjaERhdGEudGVhbTE/Lm5hbWUgfHwgXCJVbmtub3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0YWluOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnM6IHBsYXllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hEYXRhLnRlYW0yLmlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTI/Lm5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMi5uYW1lICE9PSBcIlVua25vd24gVGVhbVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTIubmFtZS50cmltKCkubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGDwn5SNIEZvdW5kIHRlYW0yOiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMj8ubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9ICgke21hdGNoRGF0YS50ZWFtMi5pZH0pYFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVhbU1hcC5oYXMobWF0Y2hEYXRhLnRlYW0yLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBwbGF5ZXJOYW1lcyBzdHJpbmcgaW50byBpbmRpdmlkdWFsIHBsYXllcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxheWVyczogV2ViUGxheWVyW10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMi5wbGF5ZXJOYW1lcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBtYXRjaERhdGEudGVhbTIucGxheWVyTmFtZXMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBg8J+UjSBUZWFtMiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTI/Lm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gcGxheWVyTmFtZXMgc3RyaW5nOmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTIucGxheWVyTmFtZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd1BsYXllck5hbWVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRGF0YS50ZWFtMi5wbGF5ZXJOYW1lcy5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBg8J+UjSBUZWFtMiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTI/Lm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gcmF3IHNwbGl0OmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdQbGF5ZXJOYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFBsYXllck5hbWVzID0gcmF3UGxheWVyTmFtZXMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWU6IHN0cmluZykgPT4gbmFtZS50cmltKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYPCflI0gVGVhbTIgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hEYXRhLnRlYW0yPy5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFmdGVyIHRyaW06YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW1tZWRQbGF5ZXJOYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxheWVyTmFtZXMgPSB0cmltbWVkUGxheWVyTmFtZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICYmIG5hbWUubGVuZ3RoID4gMCAmJiBuYW1lICE9PSBcIlBsYXllclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBg8J+UjSBUZWFtMiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hEYXRhLnRlYW0yPy5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaWx0ZXJpbmcgXCIke25hbWV9XCI6ICR7aXNWYWxpZH1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBg8J+UjSBUZWFtMiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTI/Lm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gcGFyc2VkIHBsYXllciBuYW1lczpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyTmFtZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllck5hbWVzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGxheWVyTmFtZTogc3RyaW5nLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGAke21hdGNoRGF0YS50ZWFtMiEuaWR9X3BsYXllcl8ke2luZGV4fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGxheWVyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0YWluOiBmYWxzZSwgLy8gQWxsIHBsYXllcnMgYXJlIHJlZ3VsYXIgcGxheWVycyBmb3IgcmFua2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYPCflI0gQ3JlYXRpbmcgdGVhbTI6ICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaERhdGEudGVhbTI/Lm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdpdGggJHtwbGF5ZXJzLmxlbmd0aH0gcGxheWVyc2BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGVhbU1hcC5zZXQobWF0Y2hEYXRhLnRlYW0yLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1hdGNoRGF0YS50ZWFtMi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRjaERhdGEudGVhbTI/Lm5hbWUgfHwgXCJVbmtub3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0YWluOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnM6IHBsYXllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdGVhbXMgPSBBcnJheS5mcm9tKHRlYW1NYXAudmFsdWVzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVidWc6IExvZyB0ZWFtIGFuZCBwbGF5ZXIgY291bnRzXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBUb3RhbCB0ZWFtcyBleHRyYWN0ZWQ6XCIsIHRlYW1zLmxlbmd0aCk7XG4gICAgICAgIHRlYW1zLmZvckVhY2goKHRlYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBg8J+UjSBUZWFtICR7aW5kZXggKyAxfSAoJHt0ZWFtLm5hbWV9KTogJHtcbiAgICAgICAgICAgICAgdGVhbS5wbGF5ZXJzPy5sZW5ndGggfHwgMFxuICAgICAgICAgICAgfSBwbGF5ZXJzYFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRlYW0ucGxheWVycykge1xuICAgICAgICAgICAgdGVhbS5wbGF5ZXJzLmZvckVhY2goKHBsYXllciwgcGxheWVySW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgUGxheWVyICR7cGxheWVySW5kZXggKyAxfTogJHtwbGF5ZXIubmFtZX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGF0YTogV2ViVG91cm5hbWVudERhdGEgPSB7XG4gICAgICAgICAgaWQ6IHJhdy5pZCB8fCBvdmVydmlldy50b3VybmFtZW50SWQgfHwgXCJjdXJyZW50XCIsXG4gICAgICAgICAgbmFtZTogb3ZlcnZpZXcudG91cm5hbWVudE5hbWUgfHwgcmF3Lm5hbWUgfHwgXCJUb3VybmFtZW50XCIsXG4gICAgICAgICAgc3RhdHVzOlxuICAgICAgICAgICAgb3ZlcnZpZXcuc3RhdHVzIHx8XG4gICAgICAgICAgICAocmF3LnN0YXR1cyBhcyBcInNldHVwXCIgfCBcImxpdmVcIiB8IFwiY29tcGxldGVkXCIpIHx8XG4gICAgICAgICAgICBcInNldHVwXCIsXG4gICAgICAgICAgY3VycmVudFJvdW5kOiBvdmVydmlldy5jdXJyZW50Um91bmQgfHwgcmF3LmN1cnJlbnRSb3VuZCB8fCBcIlwiLFxuICAgICAgICAgIHRlYW1zOiB0ZWFtcyxcbiAgICAgICAgICByb3VuZHM6IChBcnJheS5pc0FycmF5KHJvdW5kc0RhdGEpXG4gICAgICAgICAgICA/IHJvdW5kc0RhdGFcbiAgICAgICAgICAgIDogT2JqZWN0LmVudHJpZXMocm91bmRzRGF0YSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbLCByb3VuZF0pID0+IHJvdW5kICYmIHR5cGVvZiByb3VuZCA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAuc29ydCgoW2tleUFdLCBba2V5Ql0pID0+IHtcbiAgICAgICAgICAgICAgICAgIC8vIFNvcnQgcm91bmRzIGluIGEgY29uc2lzdGVudCBvcmRlcjogc2VtaUZpbmFsMSwgc2VtaUZpbmFsMiwgZmluYWxcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge1xuICAgICAgICAgICAgICAgICAgICBzZW1pRmluYWwxOiAxLFxuICAgICAgICAgICAgICAgICAgICBzZW1pRmluYWwyOiAyLFxuICAgICAgICAgICAgICAgICAgICBmaW5hbDogMyxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKG9yZGVyW2tleUFdIHx8IDk5OSkgLSAob3JkZXJba2V5Ql0gfHwgOTk5KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoKFssIHJvdW5kXSkgPT4gcm91bmQpXG4gICAgICAgICAgKS5tYXAoKHJvdW5kKSA9PiAoe1xuICAgICAgICAgICAgLi4uKHJvdW5kIGFzIFdlYlJvdW5kKSxcbiAgICAgICAgICAgIHRlYW0xV2luczogKHJvdW5kIGFzIFdlYlJvdW5kKS50ZWFtMVdpbnMgfHwgMCxcbiAgICAgICAgICAgIHRlYW0yV2luczogKHJvdW5kIGFzIFdlYlJvdW5kKS50ZWFtMldpbnMgfHwgMCxcbiAgICAgICAgICAgIHdpbnNOZWVkZWQ6IChyb3VuZCBhcyBXZWJSb3VuZCkud2luc05lZWRlZCB8fCA1LFxuICAgICAgICAgIH0pKSBhcyBXZWJSb3VuZFtdLFxuICAgICAgICAgIHN0cmVhbWluZ01vZGU6XG4gICAgICAgICAgICAocmF3LnN0cmVhbWluZ01vZGUgYXMgXCJub3JtYWxcIiB8IFwic3RyZWFtaW5nXCIgfCBcIm1hbnVhbFwiKSB8fFxuICAgICAgICAgICAgXCJub3JtYWxcIixcbiAgICAgICAgICBsYXN0V2ViVXBkYXRlOiB0b1NhZmVEYXRlKHJhdy5sYXN0V2ViVXBkYXRlKSxcbiAgICAgICAgICBwdXNoZWRBdDogdG9TYWZlRGF0ZShyYXcucHVzaGVkQXQpLFxuICAgICAgICAgIHB1c2hlZEJ5OiByYXcucHVzaGVkQnkgfHwgXCJcIixcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxpc3RlbmluZyB0byBzdHJlYW1pbmcgZGF0YTpcIiwgZXJyb3IpO1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICApO1xufTtcblxuLy8gR2V0IGN1cnJlbnQgc3RyZWFtaW5nIGRhdGEgKG9uZS10aW1lIHJlYWQpXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFN0cmVhbWluZ0RhdGEgPVxuICBhc3luYyAoKTogUHJvbWlzZTxXZWJUb3VybmFtZW50RGF0YSB8IG51bGw+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyZWFtaW5nUmVmID0gZG9jKGRiLCBcInN0cmVhbWluZ1wiLCBcIjV4cnA4cjc3ZHhncnd3cGVqdWE5ZnNucnJobTFcIik7XG4gICAgICBjb25zdCBkb2NTbmFwID0gYXdhaXQgZ2V0RG9jKHN0cmVhbWluZ1JlZik7XG5cbiAgICAgIGlmIChkb2NTbmFwLmV4aXN0cygpKSB7XG4gICAgICAgIGNvbnN0IHJhdyA9IGRvY1NuYXAuZGF0YSgpIGFzIEZpcmVzdG9yZURvY3VtZW50RGF0YTtcblxuICAgICAgICAvLyBIYW5kbGUgbW9iaWxlIGFwcCdzIGRhdGEgc3RydWN0dXJlXG4gICAgICAgIGNvbnN0IG92ZXJ2aWV3ID0gKHJhdy5vdmVydmlldyB8fCB7fSkgYXMgRG9jdW1lbnREYXRhO1xuICAgICAgICBjb25zdCByb3VuZHNEYXRhOiBSb3VuZHNEYXRhID0gKHJhdy5yb3VuZHMgfHwge30pIGFzIFJvdW5kc0RhdGE7XG5cbiAgICAgICAgY29uc3QgZGF0YTogV2ViVG91cm5hbWVudERhdGEgPSB7XG4gICAgICAgICAgaWQ6IHJhdy5pZCB8fCBvdmVydmlldy50b3VybmFtZW50SWQgfHwgXCJjdXJyZW50XCIsXG4gICAgICAgICAgbmFtZTogb3ZlcnZpZXcudG91cm5hbWVudE5hbWUgfHwgcmF3Lm5hbWUgfHwgXCJUb3VybmFtZW50XCIsXG4gICAgICAgICAgc3RhdHVzOlxuICAgICAgICAgICAgb3ZlcnZpZXcuc3RhdHVzIHx8XG4gICAgICAgICAgICAocmF3LnN0YXR1cyBhcyBcInNldHVwXCIgfCBcImxpdmVcIiB8IFwiY29tcGxldGVkXCIpIHx8XG4gICAgICAgICAgICBcInNldHVwXCIsXG4gICAgICAgICAgY3VycmVudFJvdW5kOiBvdmVydmlldy5jdXJyZW50Um91bmQgfHwgcmF3LmN1cnJlbnRSb3VuZCB8fCBcIlwiLFxuICAgICAgICAgIHRlYW1zOiBBcnJheS5pc0FycmF5KHJhdy50ZWFtcykgPyByYXcudGVhbXMgOiBbXSxcbiAgICAgICAgICByb3VuZHM6IChBcnJheS5pc0FycmF5KHJvdW5kc0RhdGEpXG4gICAgICAgICAgICA/IHJvdW5kc0RhdGFcbiAgICAgICAgICAgIDogT2JqZWN0LmVudHJpZXMocm91bmRzRGF0YSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbLCByb3VuZF0pID0+IHJvdW5kICYmIHR5cGVvZiByb3VuZCA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAuc29ydCgoW2tleUFdLCBba2V5Ql0pID0+IHtcbiAgICAgICAgICAgICAgICAgIC8vIFNvcnQgcm91bmRzIGluIGEgY29uc2lzdGVudCBvcmRlcjogc2VtaUZpbmFsMSwgc2VtaUZpbmFsMiwgZmluYWxcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge1xuICAgICAgICAgICAgICAgICAgICBzZW1pRmluYWwxOiAxLFxuICAgICAgICAgICAgICAgICAgICBzZW1pRmluYWwyOiAyLFxuICAgICAgICAgICAgICAgICAgICBmaW5hbDogMyxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKG9yZGVyW2tleUFdIHx8IDk5OSkgLSAob3JkZXJba2V5Ql0gfHwgOTk5KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoKFssIHJvdW5kXSkgPT4gcm91bmQpXG4gICAgICAgICAgKS5tYXAoKHJvdW5kKSA9PiAoe1xuICAgICAgICAgICAgLi4uKHJvdW5kIGFzIFdlYlJvdW5kKSxcbiAgICAgICAgICAgIHRlYW0xV2luczogKHJvdW5kIGFzIFdlYlJvdW5kKS50ZWFtMVdpbnMgfHwgMCxcbiAgICAgICAgICAgIHRlYW0yV2luczogKHJvdW5kIGFzIFdlYlJvdW5kKS50ZWFtMldpbnMgfHwgMCxcbiAgICAgICAgICAgIHdpbnNOZWVkZWQ6IChyb3VuZCBhcyBXZWJSb3VuZCkud2luc05lZWRlZCB8fCA1LFxuICAgICAgICAgIH0pKSBhcyBXZWJSb3VuZFtdLFxuICAgICAgICAgIHN0cmVhbWluZ01vZGU6XG4gICAgICAgICAgICAocmF3LnN0cmVhbWluZ01vZGUgYXMgXCJub3JtYWxcIiB8IFwic3RyZWFtaW5nXCIgfCBcIm1hbnVhbFwiKSB8fFxuICAgICAgICAgICAgXCJub3JtYWxcIixcbiAgICAgICAgICBsYXN0V2ViVXBkYXRlOiB0b1NhZmVEYXRlKHJhdy5sYXN0V2ViVXBkYXRlKSxcbiAgICAgICAgICBwdXNoZWRBdDogdG9TYWZlRGF0ZShyYXcucHVzaGVkQXQpLFxuICAgICAgICAgIHB1c2hlZEJ5OiByYXcucHVzaGVkQnkgfHwgXCJcIixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgY3VycmVudCBzdHJlYW1pbmcgZGF0YTpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4vLyBMaXN0ZW4gdG8gdGhlIHN0cmVhbSBjb250cm9sIGRvY3VtZW50IGluIHJlYWwtdGltZVxuZXhwb3J0IGNvbnN0IGxpc3RlblRvU3RyZWFtQ29udHJvbCA9IChcbiAgY2FsbGJhY2s6IChkYXRhOiBTdHJlYW1Db250cm9sRGF0YSkgPT4gdm9pZFxuKSA9PiB7XG4gIGNvbnN0IHN0cmVhbUNvbnRyb2xSZWYgPSBkb2MoZGIsIFwic3RyZWFtaW5nXCIsIFwiY3VycmVudF9zdHJlYW1fY29udHJvbFwiKTtcbiAgY29uc29sZS5sb2coXCJGSVJFQkFTRTogTGlzdGVuaW5nIHRvIHN0cmVhbSBjb250cm9sIGRvY3VtZW50Li4uXCIpO1xuXG4gIHJldHVybiBvblNuYXBzaG90KFxuICAgIHN0cmVhbUNvbnRyb2xSZWYsXG4gICAgKGRvYykgPT4ge1xuICAgICAgaWYgKGRvYy5leGlzdHMoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZJUkVCQVNFOiBTdHJlYW0gY29udHJvbCBkYXRhIHJlY2VpdmVkOlwiLCBkb2MuZGF0YSgpKTtcbiAgICAgICAgY2FsbGJhY2soZG9jLmRhdGEoKSBhcyBTdHJlYW1Db250cm9sRGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIkZJUkVCQVNFOiBTdHJlYW0gY29udHJvbCBkb2N1bWVudCBkb2VzIG5vdCBleGlzdCwgcHJvdmlkaW5nIGRlZmF1bHQuXCJcbiAgICAgICAgKTtcbiAgICAgICAgLy8gSWYgdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QsIHByb3ZpZGUgYSBkZWZhdWx0IHN0YXRlXG4gICAgICAgIGNhbGxiYWNrKHsgc3RyZWFtTWF0Y2hlczogW10sIGhpZGRlblNlY3Rpb25zOiBbXSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZJUkVCQVNFOiBFcnJvciBsaXN0ZW5pbmcgdG8gc3RyZWFtIGNvbnRyb2w6XCIsIGVycm9yKTtcbiAgICAgIC8vIFByb3ZpZGUgYSBkZWZhdWx0IHN0YXRlIG9uIGVycm9yIGFzIHdlbGxcbiAgICAgIGNhbGxiYWNrKHsgc3RyZWFtTWF0Y2hlczogW10sIGhpZGRlblNlY3Rpb25zOiBbXSB9KTtcbiAgICB9XG4gICk7XG59O1xuXG4vLyBVcGRhdGUgdGhlIHN0cmVhbSBjb250cm9sIGRvY3VtZW50XG5leHBvcnQgY29uc3QgdXBkYXRlU3RyZWFtQ29udHJvbCA9IGFzeW5jIChkYXRhOiBQYXJ0aWFsPFN0cmVhbUNvbnRyb2xEYXRhPikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xSZWYgPSBkb2MoZGIsIFwic3RyZWFtaW5nXCIsIFwiY3VycmVudF9zdHJlYW1fY29udHJvbFwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkZJUkVCQVNFOiBVcGRhdGluZyBzdHJlYW0gY29udHJvbCB3aXRoIGRhdGE6XCIsIGRhdGEpO1xuICAgIC8vIFVzZSBzZXREb2Mgd2l0aCBtZXJnZTogdHJ1ZSB0byBjcmVhdGUgdGhlIGRvYyBpZiBpdCBkb2Vzbid0IGV4aXN0IG9yIHVwZGF0ZSBpdCBpZiBpdCBkb2VzXG4gICAgYXdhaXQgc2V0RG9jKHN0cmVhbUNvbnRyb2xSZWYsIGRhdGEsIHsgbWVyZ2U6IHRydWUgfSk7XG4gICAgY29uc29sZS5sb2coXCJGSVJFQkFTRTogU3RyZWFtIGNvbnRyb2wgdXBkYXRlIHN1Y2Nlc3NmdWwuXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGSVJFQkFTRTogRXJyb3IgdXBkYXRpbmcgc3RyZWFtIGNvbnRyb2w6XCIsIGVycm9yKTtcbiAgfVxufTtcblxuLy8gRXhwbG9yZSBleGlzdGluZyBGaXJlYmFzZSBkYXRhXG5leHBvcnQgY29uc3QgZXhwbG9yZUZpcmViYXNlRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIvCflI0gRXhwbG9yaW5nIEZpcmViYXNlIGRhdGEuLi5cIik7XG4gICAgY29uc29sZS5sb2coXCLimqDvuI8gTm90ZTogU29tZSBjb2xsZWN0aW9ucyBtYXkgcmVxdWlyZSBhdXRoZW50aWNhdGlvblwiKTtcblxuICAgIC8vIFRyeSB0byBjaGVjayBzdHJlYW1pbmcgY29sbGVjdGlvbiBmaXJzdCAobW9zdCBsaWtlbHkgdG8gYmUgYWNjZXNzaWJsZSlcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyZWFtaW5nUmVmID0gZG9jKGRiLCBcInN0cmVhbWluZ1wiLCBcIjV4cnA4cjc3ZHhncnd3cGVqdWE5ZnNucnJobTFcIik7XG4gICAgICBjb25zdCBzdHJlYW1pbmdEb2MgPSBhd2FpdCBnZXREb2Moc3RyZWFtaW5nUmVmKTtcbiAgICAgIGlmIChzdHJlYW1pbmdEb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLinIUg8J+ToSBTdHJlYW1pbmcgZGF0YSBmb3VuZDpcIiwgc3RyZWFtaW5nRG9jLmRhdGEoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk6EgTm8gc3RyZWFtaW5nIGRhdGEgZm91bmQgKGNvbGxlY3Rpb24gZXhpc3RzIGJ1dCBlbXB0eSlcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgIGNvbnN0IGZpcmViYXNlRXJyb3IgPSBlcnJvciBhcyBGaXJlYmFzZUVycm9yO1xuICAgICAgaWYgKGZpcmViYXNlRXJyb3IuY29kZSA9PT0gXCJwZXJtaXNzaW9uLWRlbmllZFwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwi4p2MIPCfk6EgU3RyZWFtaW5nIGNvbGxlY3Rpb246IFBlcm1pc3Npb24gZGVuaWVkIChuZWVkcyBhdXRoZW50aWNhdGlvbilcIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLinYwg8J+ToSBTdHJlYW1pbmcgY29sbGVjdGlvbiBlcnJvcjpcIiwgZmlyZWJhc2VFcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gY2hlY2sgdXNlcnMgY29sbGVjdGlvblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2Vyc1JlZiA9IGNvbGxlY3Rpb24oZGIsIFwidXNlcnNcIik7XG4gICAgICBjb25zdCB1c2Vyc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyh1c2Vyc1JlZik7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSDwn5GlIFVzZXJzIGZvdW5kOlwiLCB1c2Vyc1NuYXBzaG90LmRvY3MubGVuZ3RoKTtcbiAgICAgIHVzZXJzU25hcHNob3QuZG9jcy5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgLSBVc2VyICR7ZG9jLmlkfTpgLCBkb2MuZGF0YSgpKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgICBjb25zdCBmaXJlYmFzZUVycm9yID0gZXJyb3IgYXMgRmlyZWJhc2VFcnJvcjtcbiAgICAgIGlmIChmaXJlYmFzZUVycm9yLmNvZGUgPT09IFwicGVybWlzc2lvbi1kZW5pZWRcIikge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIuKdjCDwn5GlIFVzZXJzIGNvbGxlY3Rpb246IFBlcm1pc3Npb24gZGVuaWVkIChuZWVkcyBhdXRoZW50aWNhdGlvbilcIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLinYwg8J+RpSBVc2VycyBjb2xsZWN0aW9uIGVycm9yOlwiLCBmaXJlYmFzZUVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyeSB0byBjaGVjayBmb3IgYW55IG90aGVyIGNvbW1vbiBjb2xsZWN0aW9uc1xuICAgIGNvbnN0IGNvbW1vbkNvbGxlY3Rpb25zID0gW1widG91cm5hbWVudHNcIiwgXCJtYXRjaGVzXCIsIFwidGVhbXNcIiwgXCJwbGF5ZXJzXCJdO1xuICAgIGZvciAoY29uc3QgY29sbGVjdGlvbk5hbWUgb2YgY29tbW9uQ29sbGVjdGlvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25SZWYgPSBjb2xsZWN0aW9uKGRiLCBjb2xsZWN0aW9uTmFtZSk7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb2xsZWN0aW9uUmVmKTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYOKchSDwn5OBICR7Y29sbGVjdGlvbk5hbWV9IGNvbGxlY3Rpb246ICR7c25hcHNob3QuZG9jcy5sZW5ndGh9IGRvY3VtZW50c2BcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHNuYXBzaG90LmRvY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNuYXBzaG90LmRvY3Muc2xpY2UoMCwgMikuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAtICR7Y29sbGVjdGlvbk5hbWV9ICR7ZG9jLmlkfTpgLCBkb2MuZGF0YSgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgICAgY29uc3QgZmlyZWJhc2VFcnJvciA9IGVycm9yIGFzIEZpcmViYXNlRXJyb3I7XG4gICAgICAgIGlmIChmaXJlYmFzZUVycm9yLmNvZGUgPT09IFwicGVybWlzc2lvbi1kZW5pZWRcIikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwg8J+TgSAke2NvbGxlY3Rpb25OYW1lfSBjb2xsZWN0aW9uOiBQZXJtaXNzaW9uIGRlbmllZGApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYOKdjCDwn5OBICR7Y29sbGVjdGlvbk5hbWV9IGNvbGxlY3Rpb24gZXJyb3I6YCxcbiAgICAgICAgICAgIGZpcmViYXNlRXJyb3IubWVzc2FnZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcIvCflI0gRXhwbG9yYXRpb24gY29tcGxldGUhXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgZXhwbG9yaW5nIEZpcmViYXNlOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyA9PT09PSBBVVRIRU5USUNBVElPTiBGVU5DVElPTlMgPT09PT1cblxuLy8gRW1haWwgdmFsaWRhdGlvbiBoZWxwZXJcbmNvbnN0IHZhbGlkYXRlRW1haWwgPSAoZW1haWw6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC87XG4gIHJldHVybiBlbWFpbFJlZ2V4LnRlc3QoZW1haWwpO1xufTtcblxuLy8gUGFzc3dvcmQgdmFsaWRhdGlvbiBoZWxwZXJcbmNvbnN0IHZhbGlkYXRlUGFzc3dvcmQgPSAocGFzc3dvcmQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAvLyBTdHJvbmcgcGFzc3dvcmQ6IG1pbiA4IGNoYXJzLCB1cHBlcmNhc2UsIGxvd2VyY2FzZSwgbnVtYmVyLCBzcGVjaWFsIGNoYXJcbiAgY29uc3QgcGFzc3dvcmRSZWdleCA9XG4gICAgL14oPz0uKlthLXpdKSg/PS4qW0EtWl0pKD89LipcXGQpKD89LipbQCQhJSo/Jl0pW0EtWmEtelxcZEAkISUqPyZdezgsfSQvO1xuICByZXR1cm4gcGFzc3dvcmRSZWdleC50ZXN0KHBhc3N3b3JkKTtcbn07XG5cbi8vIENyZWF0ZSB1c2VyIHdpdGggZW1haWwgdmVyaWZpY2F0aW9uXG5leHBvcnQgY29uc3QgY3JlYXRlVXNlcldpdGhFbWFpbFZlcmlmaWNhdGlvbiA9IGFzeW5jIChcbiAgZW1haWw6IHN0cmluZyxcbiAgcGFzc3dvcmQ6IHN0cmluZyxcbiAgZGlzcGxheU5hbWU6IHN0cmluZ1xuKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gVmFsaWRhdGUgaW5wdXRzXG4gICAgaWYgKCF2YWxpZGF0ZUVtYWlsKGVtYWlsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbWFpbCBmb3JtYXRcIik7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDggY2hhcmFjdGVycyB3aXRoIHVwcGVyY2FzZSwgbG93ZXJjYXNlLCBudW1iZXIsIGFuZCBzcGVjaWFsIGNoYXJhY3RlclwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWRpc3BsYXlOYW1lIHx8IGRpc3BsYXlOYW1lLnRyaW0oKS5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzXCIpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB1c2VyIGFjY291bnRcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZChcbiAgICAgIGF1dGgsXG4gICAgICBlbWFpbCxcbiAgICAgIHBhc3N3b3JkXG4gICAgKTtcblxuICAgIC8vIFNlbmQgZW1haWwgdmVyaWZpY2F0aW9uXG4gICAgYXdhaXQgc2VuZEVtYWlsVmVyaWZpY2F0aW9uKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xuXG4gICAgLy8gQ3JlYXRlIHVzZXIgcHJvZmlsZSBpbiBGaXJlc3RvcmVcbiAgICBhd2FpdCBzZXREb2MoZG9jKGRiLCBcInVzZXJzXCIsIHVzZXJDcmVkZW50aWFsLnVzZXIudWlkKSwge1xuICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLnRyaW0oKSxcbiAgICAgIGVtYWlsLFxuICAgICAgZW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICBpc0FkbWluOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICB1c2VyOiB1c2VyQ3JlZGVudGlhbC51c2VyLFxuICAgICAgbmVlZHNWZXJpZmljYXRpb246IHRydWUsXG4gICAgICBtZXNzYWdlOlxuICAgICAgICBcIkFjY291bnQgY3JlYXRlZCEgUGxlYXNlIGNoZWNrIHlvdXIgZW1haWwgdG8gdmVyaWZ5IHlvdXIgYWNjb3VudC5cIixcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBjcmVhdGUgYWNjb3VudFwiO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcblxuLy8gU2lnbiBpbiB1c2VyXG5leHBvcnQgY29uc3Qgc2lnbkluVXNlciA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChcbiAgICAgIGF1dGgsXG4gICAgICBlbWFpbCxcbiAgICAgIHBhc3N3b3JkXG4gICAgKTtcblxuICAgIC8vIENoZWNrIGlmIGVtYWlsIGlzIHZlcmlmaWVkXG4gICAgaWYgKCF1c2VyQ3JlZGVudGlhbC51c2VyLmVtYWlsVmVyaWZpZWQpIHtcbiAgICAgIGF3YWl0IHNpZ25PdXQoYXV0aCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiUGxlYXNlIHZlcmlmeSB5b3VyIGVtYWlsIGJlZm9yZSBzaWduaW5nIGluLiBDaGVjayB5b3VyIGluYm94IGZvciB0aGUgdmVyaWZpY2F0aW9uIGxpbmsuXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsLnVzZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiRmFpbGVkIHRvIHNpZ24gaW5cIjtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5cbi8vIFNpZ24gb3V0IHVzZXJcbmV4cG9ydCBjb25zdCBzaWduT3V0VXNlciA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzaWduT3V0KGF1dGgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBzaWduIG91dFwiO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcblxuLy8gUmVzZW5kIGVtYWlsIHZlcmlmaWNhdGlvblxuZXhwb3J0IGNvbnN0IHJlc2VuZEVtYWlsVmVyaWZpY2F0aW9uID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXNlciBsb2dnZWQgaW5cIik7XG4gICAgfVxuXG4gICAgYXdhaXQgc2VuZEVtYWlsVmVyaWZpY2F0aW9uKHVzZXIpO1xuICAgIHJldHVybiBcIlZlcmlmaWNhdGlvbiBlbWFpbCBzZW50ISBQbGVhc2UgY2hlY2sgeW91ciBpbmJveC5cIjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgIDogXCJGYWlsZWQgdG8gc2VuZCB2ZXJpZmljYXRpb24gZW1haWxcIjtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5cbi8vIERlbGV0ZSB1c2VyIGFjY291bnRcbmV4cG9ydCBjb25zdCBkZWxldGVVc2VyQWNjb3VudCA9IGFzeW5jIChwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgaWYgKCF1c2VyIHx8ICF1c2VyLmVtYWlsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB1c2VyIGxvZ2dlZCBpblwiKTtcbiAgICB9XG5cbiAgICAvLyBSZS1hdXRoZW50aWNhdGUgdXNlciBiZWZvcmUgZGVsZXRpb25cbiAgICBjb25zdCBjcmVkZW50aWFsID0gRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh1c2VyLmVtYWlsLCBwYXNzd29yZCk7XG4gICAgYXdhaXQgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbCh1c2VyLCBjcmVkZW50aWFsKTtcblxuICAgIC8vIERlbGV0ZSB1c2VyIGRhdGEgZnJvbSBGaXJlc3RvcmVcbiAgICBhd2FpdCBkZWxldGVEb2MoZG9jKGRiLCBcInVzZXJzXCIsIHVzZXIudWlkKSk7XG5cbiAgICAvLyBEZWxldGUgdXNlciBhY2NvdW50XG4gICAgYXdhaXQgZGVsZXRlVXNlcih1c2VyKTtcblxuICAgIHJldHVybiBcIkFjY291bnQgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBmaXJlYmFzZUVycm9yID0gZXJyb3IgYXMgRmlyZWJhc2VFcnJvcjtcbiAgICBjb25zdCBtZXNzYWdlID0gZmlyZWJhc2VFcnJvci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGRlbGV0ZSBhY2NvdW50XCI7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG4vLyBHZXQgY3VycmVudCB1c2VyXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFVzZXIgPSAoKSA9PiB7XG4gIHJldHVybiBhdXRoLmN1cnJlbnRVc2VyO1xufTtcblxuLy8gQ2hlY2sgaWYgdXNlciBpcyBhdXRoZW50aWNhdGVkXG5leHBvcnQgY29uc3QgaXNVc2VyQXV0aGVudGljYXRlZCA9ICgpID0+IHtcbiAgcmV0dXJuICEhYXV0aC5jdXJyZW50VXNlcjtcbn07XG5cbi8vIENoZWNrIGlmIHVzZXIgZW1haWwgaXMgdmVyaWZpZWRcbmV4cG9ydCBjb25zdCBpc0VtYWlsVmVyaWZpZWQgPSAoKSA9PiB7XG4gIHJldHVybiBhdXRoLmN1cnJlbnRVc2VyPy5lbWFpbFZlcmlmaWVkIHx8IGZhbHNlO1xufTtcblxuLy8gU2VuZCBwYXNzd29yZCByZXNldCBlbWFpbFxuZXhwb3J0IGNvbnN0IHNlbmRQYXNzd29yZFJlc2V0ID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBWYWxpZGF0ZSBlbWFpbCBmb3JtYXRcbiAgICBpZiAoIXZhbGlkYXRlRW1haWwoZW1haWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGVtYWlsIGZvcm1hdFwiKTtcbiAgICB9XG5cbiAgICBhd2FpdCBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGF1dGgsIGVtYWlsKTtcbiAgICByZXR1cm4gXCJQYXNzd29yZCByZXNldCBlbWFpbCBzZW50ISBQbGVhc2UgY2hlY2sgeW91ciBpbmJveCBhbmQgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMuXCI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZmlyZWJhc2VFcnJvciA9IGVycm9yIGFzIEZpcmViYXNlRXJyb3I7XG4gICAgLy8gSGFuZGxlIHNwZWNpZmljIEZpcmViYXNlIGVycm9yc1xuICAgIGlmIChmaXJlYmFzZUVycm9yLmNvZGUgPT09IFwiYXV0aC91c2VyLW5vdC1mb3VuZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhY2NvdW50IGZvdW5kIHdpdGggdGhpcyBlbWFpbCBhZGRyZXNzXCIpO1xuICAgIH0gZWxzZSBpZiAoZmlyZWJhc2VFcnJvci5jb2RlID09PSBcImF1dGgvaW52YWxpZC1lbWFpbFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGVtYWlsIGFkZHJlc3NcIik7XG4gICAgfSBlbHNlIGlmIChmaXJlYmFzZUVycm9yLmNvZGUgPT09IFwiYXV0aC90b28tbWFueS1yZXF1ZXN0c1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVG9vIG1hbnkgcGFzc3dvcmQgcmVzZXQgYXR0ZW1wdHMuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGZpcmViYXNlRXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBzZW5kIHBhc3N3b3JkIHJlc2V0IGVtYWlsXCJcbiAgICApO1xuICB9XG59O1xuXG4vLyBVcGRhdGUgcGFzc3dvcmQgKGZvciBsb2dnZWQtaW4gdXNlcnMpXG5leHBvcnQgY29uc3QgdXBkYXRlVXNlclBhc3N3b3JkID0gYXN5bmMgKFxuICBjdXJyZW50UGFzc3dvcmQ6IHN0cmluZyxcbiAgbmV3UGFzc3dvcmQ6IHN0cmluZ1xuKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgaWYgKCF1c2VyIHx8ICF1c2VyLmVtYWlsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB1c2VyIGxvZ2dlZCBpblwiKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBuZXcgcGFzc3dvcmRcbiAgICBpZiAoIXZhbGlkYXRlUGFzc3dvcmQobmV3UGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTmV3IHBhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzIHdpdGggdXBwZXJjYXNlLCBsb3dlcmNhc2UsIG51bWJlciwgYW5kIHNwZWNpYWwgY2hhcmFjdGVyXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmUtYXV0aGVudGljYXRlIHVzZXJcbiAgICBjb25zdCBjcmVkZW50aWFsID0gRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChcbiAgICAgIHVzZXIuZW1haWwsXG4gICAgICBjdXJyZW50UGFzc3dvcmRcbiAgICApO1xuICAgIGF3YWl0IHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwodXNlciwgY3JlZGVudGlhbCk7XG5cbiAgICAvLyBVcGRhdGUgcGFzc3dvcmRcbiAgICBhd2FpdCB1cGRhdGVQYXNzd29yZCh1c2VyLCBuZXdQYXNzd29yZCk7XG5cbiAgICByZXR1cm4gXCJQYXNzd29yZCB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGZpcmViYXNlRXJyb3IgPSBlcnJvciBhcyBGaXJlYmFzZUVycm9yO1xuICAgIGlmIChmaXJlYmFzZUVycm9yLmNvZGUgPT09IFwiYXV0aC93cm9uZy1wYXNzd29yZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJyZW50IHBhc3N3b3JkIGlzIGluY29ycmVjdFwiKTtcbiAgICB9IGVsc2UgaWYgKGZpcmViYXNlRXJyb3IuY29kZSA9PT0gXCJhdXRoL3dlYWstcGFzc3dvcmRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV3IHBhc3N3b3JkIGlzIHRvbyB3ZWFrXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoZmlyZWJhc2VFcnJvci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHVwZGF0ZSBwYXNzd29yZFwiKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZGIsIGF1dGggfTtcbiJdLCJuYW1lcyI6WyJpbml0aWFsaXplQXBwIiwiZ2V0RmlyZXN0b3JlIiwiZG9jIiwib25TbmFwc2hvdCIsImdldERvYyIsImNvbGxlY3Rpb24iLCJnZXREb2NzIiwic2V0RG9jIiwiZGVsZXRlRG9jIiwiZ2V0QXV0aCIsImNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZCIsInNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkIiwic2lnbk91dCIsInNlbmRFbWFpbFZlcmlmaWNhdGlvbiIsInNlbmRQYXNzd29yZFJlc2V0RW1haWwiLCJkZWxldGVVc2VyIiwidXBkYXRlUGFzc3dvcmQiLCJyZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsIiwiRW1haWxBdXRoUHJvdmlkZXIiLCJmaXJlYmFzZUNvbmZpZyIsInZhbGlkYXRlRmlyZWJhc2VDb25maWciLCJhcHAiLCJkYiIsImF1dGgiLCJ0b1NhZmVEYXRlIiwidmFsdWUiLCJEYXRlIiwiZCIsImlzTmFOIiwiZ2V0VGltZSIsInRvRGF0ZSIsImxpc3RlblRvU3RyZWFtaW5nRGF0YSIsImNhbGxiYWNrIiwiY29uc29sZSIsImxvZyIsInN0cmVhbWluZ1JlZiIsImV4aXN0cyIsInJhdyIsImRhdGEiLCJvdmVydmlldyIsInJvdW5kc0RhdGEiLCJyb3VuZHMiLCJ0ZWFtcyIsImNoYW1waW9uIiwiT2JqZWN0Iiwia2V5cyIsInRlYW1zRGF0YSIsInRlYW1MaXN0IiwicGFydGljaXBhbnRzIiwiZW50cmllcyIsImZvckVhY2giLCJyb3VuZEtleSIsInJvdW5kRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsIm1hdGNoZXMiLCJyb3VuZCIsIm1hdGNoIiwibWF0Y2hJbmRleCIsIm1hdGNoT2JqIiwidGVhbTEiLCJ0ZWFtMiIsImxlbmd0aCIsInRlYW1NYXAiLCJNYXAiLCJ2YWx1ZXMiLCJyb3VuZEluZGV4IiwibWF0Y2hEYXRhIiwiaWQiLCJuYW1lIiwidHJpbSIsImhhcyIsInBsYXllcnMiLCJwbGF5ZXJOYW1lcyIsInJhd1BsYXllck5hbWVzIiwic3BsaXQiLCJ0cmltbWVkUGxheWVyTmFtZXMiLCJtYXAiLCJmaWx0ZXIiLCJpc1ZhbGlkIiwicGxheWVyTmFtZSIsImluZGV4IiwicHVzaCIsImNhcHRhaW4iLCJzZXQiLCJtYW5hZ2VyIiwiY29sb3IiLCJpY29uIiwiZnJvbSIsInRlYW0iLCJwbGF5ZXIiLCJwbGF5ZXJJbmRleCIsInRvdXJuYW1lbnRJZCIsInRvdXJuYW1lbnROYW1lIiwic3RhdHVzIiwiY3VycmVudFJvdW5kIiwic29ydCIsImtleUEiLCJrZXlCIiwib3JkZXIiLCJzZW1pRmluYWwxIiwic2VtaUZpbmFsMiIsImZpbmFsIiwidGVhbTFXaW5zIiwidGVhbTJXaW5zIiwid2luc05lZWRlZCIsInN0cmVhbWluZ01vZGUiLCJsYXN0V2ViVXBkYXRlIiwicHVzaGVkQXQiLCJwdXNoZWRCeSIsImVycm9yIiwiZ2V0Q3VycmVudFN0cmVhbWluZ0RhdGEiLCJkb2NTbmFwIiwibGlzdGVuVG9TdHJlYW1Db250cm9sIiwic3RyZWFtQ29udHJvbFJlZiIsInN0cmVhbU1hdGNoZXMiLCJoaWRkZW5TZWN0aW9ucyIsInVwZGF0ZVN0cmVhbUNvbnRyb2wiLCJtZXJnZSIsImV4cGxvcmVGaXJlYmFzZURhdGEiLCJzdHJlYW1pbmdEb2MiLCJmaXJlYmFzZUVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJ1c2Vyc1JlZiIsInVzZXJzU25hcHNob3QiLCJkb2NzIiwiY29tbW9uQ29sbGVjdGlvbnMiLCJjb2xsZWN0aW9uTmFtZSIsImNvbGxlY3Rpb25SZWYiLCJzbmFwc2hvdCIsInNsaWNlIiwidmFsaWRhdGVFbWFpbCIsImVtYWlsIiwiZW1haWxSZWdleCIsInRlc3QiLCJ2YWxpZGF0ZVBhc3N3b3JkIiwicGFzc3dvcmQiLCJwYXNzd29yZFJlZ2V4IiwiY3JlYXRlVXNlcldpdGhFbWFpbFZlcmlmaWNhdGlvbiIsImRpc3BsYXlOYW1lIiwiRXJyb3IiLCJ1c2VyQ3JlZGVudGlhbCIsInVzZXIiLCJ1aWQiLCJlbWFpbFZlcmlmaWVkIiwiY3JlYXRlZEF0IiwiaXNBZG1pbiIsIm5lZWRzVmVyaWZpY2F0aW9uIiwic2lnbkluVXNlciIsInNpZ25PdXRVc2VyIiwicmVzZW5kRW1haWxWZXJpZmljYXRpb24iLCJjdXJyZW50VXNlciIsImRlbGV0ZVVzZXJBY2NvdW50IiwiY3JlZGVudGlhbCIsImdldEN1cnJlbnRVc2VyIiwiaXNVc2VyQXV0aGVudGljYXRlZCIsImlzRW1haWxWZXJpZmllZCIsInNlbmRQYXNzd29yZFJlc2V0IiwidXBkYXRlVXNlclBhc3N3b3JkIiwiY3VycmVudFBhc3N3b3JkIiwibmV3UGFzc3dvcmQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/firebase.ts\n"));

/***/ })

});